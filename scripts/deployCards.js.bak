import { createWalletClient, createPublicClient, http, parseAbi, defineChain } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Default Anvil private key (account #0)
const PRIVATE_KEY = process.env.PRIVATE_KEY || '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';

// Define chain configuration based on environment
const baseSepolia = defineChain({
  id: 84532,
  name: 'Base Sepolia',
  nativeCurrency: {
    decimals: 18,
    name: 'Ether',
    symbol: 'ETH',
  },
  rpcUrls: {
    default: { http: ['https://sepolia.base.org'] },
  },
});

const anvil = defineChain({
  id: 31337,
  name: 'Anvil',
  nativeCurrency: {
    decimals: 18,
    name: 'Ether',
    symbol: 'ETH',
  },
  rpcUrls: {
    default: { http: ['http://localhost:8545'] },
  },
});

// Determine which chain to use
const isBaseSepolia = process.env.NETWORK === 'base_sepolia';
const chain = isBaseSepolia ? baseSepolia : anvil;

// Get CardRegistry address from command line or environment
const CARD_REGISTRY_ADDRESS = process.argv[2] || process.env.CARD_REGISTRY_ADDRESS;

if (!CARD_REGISTRY_ADDRESS) {
  console.error('Please provide CardRegistry address as argument or set CARD_REGISTRY_ADDRESS env variable');
  console.error('Usage: node scripts/deployCards.js <CARD_REGISTRY_ADDRESS>');
  process.exit(1);
}

// CardRegistry ABI
const cardRegistryAbi = parseAbi([
  'function addCard(string memory _name, string memory _description, uint256 _cost, uint8 _cardType, string[] memory _abilityNames, string[][] memory _abilityKeys, string[][] memory _abilityValues) public returns (uint256)',
  'function addCardSimple(string memory _name, string memory _description, uint256 _cost, uint8 _cardType) external returns (uint256)',
  'function markInitialized() external',
  'function getCardCount() external view returns (uint256)',
  'function owner() external view returns (address)'
]);

// Card types enum - updated to match contract
const CardTypes = {
  'Chain': 0,
  'DeFi': 1,
  'EOA': 2,
  'Action': 3,
  'Ability': 3  // Map Ability to Action type
};

async function deployCards() {
  const startTime = Date.now();
  console.log('🚀 Starting card deployment...\n');
  console.log('Setting up clients...');
  
  // Setup account
  const account = privateKeyToAccount(PRIVATE_KEY);
  
  // Setup clients
  const walletClient = createWalletClient({
    account,
    chain: chain,
    transport: http(chain.rpcUrls.default.http[0]),
  });
  
  const publicClient = createPublicClient({
    chain: chain,
    transport: http(chain.rpcUrls.default.http[0]),
  });
  
  console.log('Using account:', account.address);
  console.log('CardRegistry address:', CARD_REGISTRY_ADDRESS);
  
  // Check owner
  const owner = await publicClient.readContract({
    address: CARD_REGISTRY_ADDRESS,
    abi: cardRegistryAbi,
    functionName: 'owner',
  });
  
  console.log('Contract owner:', owner);
  
  if (owner.toLowerCase() !== account.address.toLowerCase()) {
    console.error('Error: Current account is not the owner of CardRegistry');
    process.exit(1);
  }
  
  // Load cards from JSON
  const cardsPath = join(__dirname, '..', 'data', 'cards.json');
  const cardsData = JSON.parse(readFileSync(cardsPath, 'utf8'));
  
  const totalCards = cardsData.cards.length;
  console.log(`\n📦 Loading ${totalCards} cards from cards.json...\n`);
  
  // Function to update progress bar
  function updateProgress(current, total, message) {
    const percentage = Math.round((current / total) * 100);
    const barLength = 30;
    const filledLength = Math.round((current / total) * barLength);
    const bar = '█'.repeat(filledLength) + '░'.repeat(barLength - filledLength);
    
    // Clear current line and write progress
    process.stdout.write(`\r[${bar}] ${percentage}% (${current}/${total}) - ${message}`);
  }
  
  console.log('⚡ Sending all card transactions rapidly...\n');
  
  const transactions = [];
  const failedCards = [];
  
  // Send all transactions without waiting
  for (let i = 0; i < cardsData.cards.length; i++) {
    const card = cardsData.cards[i];
    updateProgress(i + 1, totalCards, `Sending: ${card.name}`);
    
    // Prepare abilities data
    const abilityNames = [];
    const abilityKeys = [];
    const abilityValues = [];
    
    // Handle abilities as an object with nested ability objects
    if (card.abilities && typeof card.abilities === 'object') {
      for (const [abilityName, abilityData] of Object.entries(card.abilities)) {
        abilityNames.push(abilityName);
        
        const keys = [];
        const values = [];
        
        // Each ability is an object with properties
        if (abilityData && typeof abilityData === 'object') {
          for (const [key, value] of Object.entries(abilityData)) {
            keys.push(key);
            values.push(String(value));
          }
        }
        
        abilityKeys.push(keys);
        abilityValues.push(values);
      }
    }
    
    // Validate card type
    if (!CardTypes.hasOwnProperty(card.cardType)) {
      failedCards.push(`${card.name} (invalid type: ${card.cardType})`);
      continue;
    }
    
    try {
      let hash;
      // If card has abilities, use addCard; otherwise use addCardSimple
      if (abilityNames.length > 0) {
        hash = await walletClient.writeContract({
          address: CARD_REGISTRY_ADDRESS,
          abi: cardRegistryAbi,
          functionName: 'addCard',
          args: [
            card.name,
            card.description,
            BigInt(card.cost),
            CardTypes[card.cardType],
            abilityNames,
            abilityKeys,
            abilityValues
          ],
        });
      } else {
        hash = await walletClient.writeContract({
          address: CARD_REGISTRY_ADDRESS,
          abi: cardRegistryAbi,
          functionName: 'addCardSimple',
          args: [
            card.name,
            card.description,
            BigInt(card.cost),
            CardTypes[card.cardType]
          ],
        });
      }
      
      transactions.push({ hash, card: card.name });
      
    } catch (error) {
      console.error(`\n❌ Failed to send tx for ${card.name}: ${error.message?.substring(0, 100)}`);
      failedCards.push(`${card.name}`);
    }
  }
  
  // Complete progress bar
  updateProgress(totalCards, totalCards, 'All transactions sent!');
  console.log('\n');
  
  console.log(`\n⏳ Waiting for ${transactions.length} transactions to be confirmed...\n`);
  
  // Now wait for all transactions to be confirmed
  let confirmedCount = 0;
  const confirmationPromises = transactions.map(async (tx) => {
    try {
      await publicClient.waitForTransactionReceipt({ hash: tx.hash });
      confirmedCount++;
      updateProgress(confirmedCount, transactions.length, `Confirmed: ${tx.card}`);
      return true;
    } catch (error) {
      console.error(`\n❌ Failed to confirm ${tx.card}: ${error.message?.substring(0, 100)}`);
      failedCards.push(`${tx.card} (confirmation failed)`);
      return false;
    }
  });
  
  const confirmationResults = await Promise.all(confirmationPromises);
  const successCount = confirmationResults.filter(r => r).length;
  
  console.log('\n');
  
  // Show results
  if (failedCards.length > 0) {
    console.log(`\n⚠️  Failed to add ${failedCards.length} cards:`);
    failedCards.forEach(card => console.log(`   - ${card}`));
  }
  
  // Mark as initialized
  process.stdout.write('\n📝 Marking registry as initialized...');
  try {
    const initHash = await walletClient.writeContract({
      address: CARD_REGISTRY_ADDRESS,
      abi: cardRegistryAbi,
      functionName: 'markInitialized',
    });
    
    await publicClient.waitForTransactionReceipt({ hash: initHash });
    console.log(' ✓');
  } catch (error) {
    console.log(' ❌ Failed to mark as initialized');
  }
  
  // Get final card count
  const cardCount = await publicClient.readContract({
    address: CARD_REGISTRY_ADDRESS,
    abi: cardRegistryAbi,
    functionName: 'getCardCount',
  });
  
  const endTime = Date.now();
  const totalTime = ((endTime - startTime) / 1000).toFixed(2);
  
  console.log(`\n✅ Successfully deployed ${successCount}/${totalCards} cards in ${totalTime} seconds!`);
  console.log(`   Total cards in registry: ${cardCount}`);
  if (successCount > 0) {
    console.log(`   Average time per card: ${(totalTime / successCount).toFixed(2)}s`);
  }
}

// Run deployment
deployCards().catch(error => {
  console.error('Deployment failed:', error);
  process.exit(1);
});